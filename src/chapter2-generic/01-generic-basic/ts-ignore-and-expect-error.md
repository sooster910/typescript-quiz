
## @ts-expect-error, @ts-ignore 지시어 그냥 타입을 맞추면 되지 않나?

두 지시어는 모두 타입스크립트 컴파일러(tsc) 가 특별하게 해석하는 주석입니다.
처음엔 “왜 이런 게 필요하지? 그냥 타입을 맞추면 되지 않나?” 라고 생각 했을 수 있습니다.

## 불완전한 현실

그러나 현실은 불완전합니다.
외부 라이브러리의 타입 정의가 실제 구현과 달라서, 정상 작동하는 코드가 타입 에러로 막히는 경우가 있습니다.
예를 들어 @types 패키지에서 함수 파라미터를 number로 정의했는데 실제 구현은 string 을 받아도 동작할 수 있죠.

이런 상황에서 개발자가 할 수 있는 선택지는 크게 두 가지입니다.
1. 직접 타입 정의를 수정하거나 declare module을 통해 덮어씌운다.
2. 급한 경우, 타입 체크를 우회해서 넘어간다.

여기서 1번은 가장 바람직하지만 시간이 많이 들고, 당장 배포해야 하는 경우엔 쉽지 않습니다.
그래서 2번을 선택하게 되는데, 이때 `@ts-ignore` 와 `@ts-expect-error` 의 쓰임의 목적이 드러납니다.

## 타입스크립트 철학과 현실의 타협:  하지만 에러만 무시하다 고칠기회를 놓침

특히나 타입스크립트의 철학과 관련해서 이야기해보자면, TypeScript의 목표는 JS에 타입 안전성을 더하면서도, 기존 JS 코드와 호환성을 유지하는 것이다.
현실의 수많은 JS 코드(완벽하지 않은 코드, 타입 없는 코드, 타입 정의 틀린 라이브러리 등)를 "당장 다 고치라" 하면 아무도 TS 를 쓰지않을것이다.
어떤 부분은 “지금은 에러를 무시하고 넘어가야” 하는 상황이 필연적으로 생깁니다.
따라서 현실적 타협안인 `@ts-ignore`을 사용해왔습니다. 하지만 단점은 여기서 에러를 무시하다가 나중에 고칠 기회를 놓치는 일이 많았어요.

## `@ts-expect-error`: 침묵 보단 터트려서 의도 알려주기
TypeScript 3.9(2020년) 부터 // @ts-expect-error 가 도입되었습니다.
여기서는 의도적으로 에러가 나야 한다는 상황을 명시할 수 있습니다. 
그런데 에러가 나야 하는 상황을 왜 명시해야 했을까?

예를 들어 다음과 같은 상황을 생각해봅시다.
@ts-expect-error 를 사용하지 않으면, 런타임은 괜찮지만 컴파일러에선 에러가 납니다. 그리고 이건 나중에 고쳐야 할 문제입니다.
이럴 때 @ts-expect-error 를 사용하면, "여기선 에러가 나는 게 맞아" 라고 명확히 표시할 수 있습니다.

```typescript
// 라이브러리 타입 정의 (사내 개발자가 잘못 단언함)
declare function onlyNumber(x: string): void;

// 실제 사용
// @ts-expect-error
onlyNumber(111); // number를 넣었는데, 타입 정의는 string만 허용 → 컴파일러 에러 발생
```
사내 개발자가 고쳤습니다.

```typescript// 라이브러리 타입 정의 (수정됨)
declare function onlyNumber(x: number): void;
// 실제 사용
// @ts-expect-error
onlyNumber(111); // 이제 에러가 안 남 → ts가 "기대한 에러가 안 났다"고 컴파일 에러를 냄
``` 

이제 컴파일러가 "기대한 에러가 안 났다"고 컴파일 에러를 냅니다.
즉, `@ts-expect-error`는 "여기선 에러가 나는 게 맞아" 라고 명확히 표시하는 역할을 합니다.
따라서 타입 정의가 수정되어 타입체커가 실제로 타입에러를 내지 않게 되면 이 주석은 필요없다고 해당 지시어에 빨간줄이 나옵니다.
이 때 `@ts-expect-error` 주석을 제거해야 합니다.  이렇게 하면 나중에 고칠 기회를 놓치지 않고, 코드의 의도를 명확히 전달할 수 있습니다.


## 정리

| 특징                        | `//@ts-expect-error` (에러 예상)                                                                                             | `//@ts-ignore` (에러 무시)                                                               |
| --------------------------- | ---------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| **기본 동작**               | 다음 줄에서 에러가 발생할 것을 예상하고 무시합니다.                                                                          | 다음 줄에서 발생하는 에러를 무조건 무시합니다.                                           |
| **에러가 발생하지 않을 때** | 다음 줄의 코드를 수정하여 에러가 해결되면, 타입스크립트가 `Unnecessary '@ts-expect-error' directive`라는 경고를 띄웁니다. ⚠️ | 다음 줄의 코드를 수정하여 에러가 해결되어도, 아무런 알림 없이 조용히 넘어갑니다.         |
| **목적**                    | 에러가 발생하는 것이 의도된 상황임을 표시하고, 에러가 해결되면 주석을 제거하도록 강제합니다. (안전 장치)                     | 임시로 컴파일 에러를 억제하여 당장의 빌드를 통과시키기 위함입니다.                       |
| **안전성**                  | 에러가 해결되면 알려주기 때문에 불필요한 코드가 남는 것을 방지하여 안전합니다. 👍                                            | 에러가 해결되어도 주석이 남아 코드의 타입 안전성을 불필요하게 낮추는 위험이 있습니다. 👎 |

- **타입 안전성**을 유지하면서도 필요한 경우에만 에러를 우회할 수 있고
- **코드의 의도**를 명확히 표현하여 팀원들이 이해하기 쉬워지며
- **장기적으로 유지보수**가 용이한 코드를 작성할 수 있다
  반대로 잘못 사용하면 타입 시스템의 장점을 잃어버리고 런타임 에러의 위험을 높일 수 있으니 왜 이런 지시어가 생겼는지를 항상 고민하며 사용하게 되면
가독성있는 맥락을 살린 코드를 작성할 수 있습니다.

