## 고차함수 타입 설계

function을 리턴하는 함수를 작성해보자

```tsx
function withLog(){
  return ()=>{
    return "hi"
  }
}

const logFunction = withLog()
console.log(logFunction())
```

`logFunction` 엔 함수가 값으로 할당되어있다.  그러므로 현재 값자체만으로는 호출이 어렵다. 그러니 함수호출을 해줌으로써 `()⇒{return “hi”}` 가 나올수있다.

함수를 호출할 수 있다는건 인자또한 넣어줄수있다.  여기에 들어가는 인자는 return 함수로 들어간다. 코드로 보면 다음과 같다.

```tsx
function withLog(param){
    return (name)=> `${param},${name}`
}
const todayLog = withLog("log")
console.log(todayLog("sue"))

```

그럼 withLog 에 인자를 받아보고 제네릭을 붙여보자.

```tsx
function withLog<T>(param:T){
    return (name:string)=> `${param},${name}`
}
const todayLog = withLog("log")
console.log(todayLog("sue"))

```

그런데 함수로 인자를 보내면, 바로 타입에러가 난다.

그 이유는 현재 인자의 타입을 모르는 상태에서 인자를 직접적으로 호출하기 때문이다.

만약 string 인자타입을 주었다면 string인자를 호출할수없기 때문에 이는 not callable이라는 에러를 뱉어낸다.

그럼 어떻게 해야할까?

제약을 줘야 한다.

```tsx
function withLog<T extends (...args:any)=>any>(param:T){
    return ()=> {
        return param()
    }
}

const todayLog = withLog(()=>"log")
console.log(todayLog()) //log

```

여기서 좀 더 나아가 인자를 받는 함수를 넘겨줘보자.

```tsx
function withLog<T extends (...args:any)=>any>(param:T){
    return ()=> {
        return param()
    }
}

const add = (num1:number, num2:number) => num1+num2
const addNumberLog = withLog(add)
console.log(addNumberLog()) //NaN

```

add라는 함수를 그대로 넘겼더니 `NaN` 가 나왔다.

여기서 문제는 add 라는 함수는 굉장히 구체적으로 `number`타입의 두개의 인자를 요구하는데, add라는 함수만 핸들링 하려면 가능하겠지만, withLog의 쓰임새를 생각했을 때 add 라는 함수외 다른 함수시그니처를 요구하는 함수들이 사용되어야 한다.

```tsx
function withLog<T extends (...args:any[])=>any>(param:T){
    return (...args)=> {
        return param(...args)
    }
}

const add = (num1:number, num2:number) => num1+num2
const addNumberLog = withLog(add)

console.log(addNumberLog(1,2)) //3

```

withLog는 그 자체로서 일을 하고 add 함수에 필요한 인자를 넘겨주었다.

이 코드는 다른 함수시그니처를 요구할때도 유연하다.

```tsx
function withLog<T extends (...args:any[])=>any>(param:T){
    return (...args)=> {
        return param(...args)
    }
}

const add = (num1:number, num2:number) => num1+num2
const addNumberLog = withLog(add)
console.log(addNumberLog(1,2))

const printString = (anything:string)=> `${anything}`
const executeLog = withLog(printString)
console.log(executeLog(12))

```

하지만 현재 `withLog`  함수에 적용된 타입만으로는 부족하다.


args가 어떤 타입인지 모른다는것이다. 현재 any[] 타입으로 implicitly 하게 추론하고 있어, 아무 타입이나 다 받는다는게 문제다 .

```tsx
const add = (num1:number, num2:number) => num1+num2
const addNumberLog = withLog(add)
console.log(addNumberLog("hey","you")) //heyyou
```

타입스크립트는 rest parameter의 타입을 자동으로 추론하지 못해 number를 요구하는곳에 string을 넘겨줘도 아무런 타입에러가 나지 않는다.
우리에게 필요한건 `...args` 가 `withLog` 함수의 인자 내부에 해당하는 인자타입을 정확히 추론해야 한다.

이 때 `Parameters<T>`타입이 유용하다.
